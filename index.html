<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
        }
        .explanation-box {
            transition: opacity 0.5s ease-in-out, max-height 0.5s ease-in-out;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }
        .explanation-box.visible {
            max-height: 500px; /* Adjust as needed for content */
            opacity: 1;
        }
        .option-btn.selected {
            border-color: #3b82f6; /* blue-500 */
            border-width: 2px;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .option-btn.correct {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e; /* green-500 */
            color: #15803d; /* green-700 */
        }
        .option-btn.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
            color: #b91c1c; /* red-700 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="quiz-container" class="container mx-auto p-4 md:p-8" style="max-width: 1500px;">
        <!-- Header: Title, Score, Timer, Reset -->
        <header class="bg-white p-4 rounded-lg shadow-md mb-6 sticky top-0 z-10">
            <div class="flex flex-wrap justify-between items-center gap-4">
                <h1 id="main-title" class="text-2xl md:text-3xl font-bold text-gray-700"></h1>
                <div class="flex items-center gap-3">
                    <div id="scoreboard" class="text-sm font-semibold bg-blue-100 text-blue-800 px-3 py-1 rounded-lg">Score: 0 / 0</div>
                    <div id="timer" class="text-sm font-mono bg-gray-200 px-3 py-1 rounded-lg">00:00:00</div>
                    <button id="reset-quiz-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg transition-colors text-sm">Reset Quiz</button>
                </div>
            </div>
        </header>

        <!-- Main content for questions -->
        <main id="questions-wrapper">
            <!-- Questions will be injected here by JavaScript -->
        </main>

        <!-- Navigation -->
        <nav id="navigation-controls" class="mt-6 flex justify-between items-center bg-white p-3 rounded-lg shadow-md sticky bottom-0 z-10">
            <button id="prev-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed">Previous</button>
            <div class="flex items-center gap-2">
                <label for="question-jump" class="text-sm font-medium">Jump to:</label>
                <select id="question-jump" class="border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
            </div>
            <button id="next-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition-colors disabled:bg-blue-300 disabled:cursor-not-allowed">Next</button>
        </nav>
    </div>
    
    <!-- External script with quiz data -->
    <script src="test.js"></script>

    <!-- Main application logic -->
    <script>
        const cookie_name = "json0";
const main_title = "AWS SysOps Practice Quiz";
 // --- DATA SOURCE ---
const questions = [
 {
        "number": 1,
        "title": "EC2 Connectivity Timeout (Based on #339)",
        "scenario": "A SysOps administrator launches a new Amazon EC2 Linux instance into a public subnet.  The instance is running, and the administrator has its public IP address.  However, every attempt to connect remotely (e.g., via SSH) results in a connection timeout error. ",
        "questionText": "Which action will allow the SysOps administrator to remotely connect to the instance? ",
        "isMultiChoice": false,
        "options": [
            {
                "letter": "A",
                "text": "Add a route table entry in the public subnet for the SysOps administrator's IP address. "
            },
            {
                "letter": "B",
                "text": "Add an outbound network ACL rule to allow TCP port 22 for the SysOps administrator's IP address. "
            },
            {
                "letter": "C",
                "text": "Modify the instance security group to allow inbound SSH traffic from the SysOps administrator's IP address. "
            },
            {
                "letter": "D",
                "text": "Modify the instance security group to allow outbound SSH traffic to the SysOps administrator's IP address. "
            }
        ],
        "correctAnswers": ["C"],
        "explanation": "Correct Answer: C \nExplanation: A connection timeout error is a classic sign that a firewall is blocking the traffic before it can reach the destination.  In AWS, the primary firewall protecting an EC2 instance is its Security Group.  By default, security groups deny all inbound traffic.  To connect to a Linux instance using SSH, you must explicitly allow inbound traffic on TCP port 22.  Modifying the security group to add an inbound rule for port 22 from the administrator's specific IP address is the correct and most secure solution. ",
        "wrongExplanation": "Why the others are wrong: \nA: Route tables control the flow of traffic between subnets and to destinations outside the VPC (like the internet via an Internet Gateway).  They do not filter traffic to a specific instance based on port or IP.  The instance is in a public subnet, which should already have a route to the Internet Gateway. \nB: This is incorrect for two reasons.  First, the problem is with inbound traffic to the instance, not outbound.  Second, Network ACLs are stateless, but they are less commonly the cause of initial connection issues than security groups.  The default Network ACL allows all traffic. \nD: The connection attempt is an inbound request to the EC2 instance.  An outbound rule controls traffic leaving the instance.  While outbound rules are important, they are not the cause of this specific problem. "
    },
{
  "number": 88,
  "title": "CloudFormation Advanced Terminology",
  "scenario": "A DevOps team is managing a critical, multi-resource production stack using AWS CloudFormation. Their primary concerns are preventing accidental updates to their RDS database instance and ensuring that any proposed changes to the stack can be reviewed for potential impact before being applied. They need to implement controls that are native to the CloudFormation service.",
  "questionText": "Which two CloudFormation features or concepts are essential for preventing unintended resource modifications and safely managing updates to a critical production stack? (Choose two)",
  "isMultiChoice": true,
  "options": [
    {
      "letter": "A",
      "text": "A Stack Policy with an \"Allow\" effect for all actions on all resources."
    },
    {
      "letter": "B",
      "text": "A Change Set, generated before updating the stack."
    },
    {
      "letter": "C",
      "text": "A Stack Policy with a \"Deny\" effect for \"Update:\" actions on the logical ID of the production database."
    },
    {
      "letter": "D",
      "text": "A DeletionPolicy of \"Snapshot\" on the database resource."
    },
    {
      "letter": "E",
      "text": "Drift Detection scheduled to run daily on the stack."
    }
  ],
  "correctAnswers": [
    "B",
    "C"
  ],
  "explanation": "Why B and C are correct: \n**B** is correct because a **Change Set** is the CloudFormation feature designed specifically for previewing changes. It provides a summary of the proposed modifications (creations, updates, deletions) to a stack's resources, allowing the team to review the impact before executing the update, which is a critical safety practice.\n**C** is correct because a **Stack Policy** is a JSON document that controls which update actions can be performed on which resources within a stack. Applying a policy with a \"Deny\" effect on update actions for the logical ID of the database directly prevents any CloudFormation update operation from modifying that specific resource, thus protecting it from accidental changes.",
  "wrongExplanation": "Why the others are wrong: \n**A**: A Stack Policy that allows all actions provides no protection whatsoever; the default behavior is to allow all updates, so this policy would be redundant and ineffective. \n**D**: A DeletionPolicy of \"Snapshot\" or \"Retain\" only applies when the entire stack is deleted or when the resource itself is removed from the template. It does not prevent in-place updates or modifications to the resource while it remains part of the stack. \n**E**: Drift Detection is a detective control, not a preventative one. It identifies when a resource's actual configuration has deviated from its expected configuration in the template (e.g., due to manual changes). It reports on drift but does not prevent CloudFormation from applying intended (or unintended) updates."
}
 
]
        // --- STATE MANAGEMENT ---
        let currentQuestionIndex = 0;
        let score = 0;
        let userSelections;
        let answeredCorrectly;
        
        // Timer state
        let timerInterval;
        let totalSeconds = 0;
        let inactivityTimer;

        // --- DOM ELEMENTS ---
        const mainTitleEl = document.getElementById('main-title');
        const scoreboardEl = document.getElementById('scoreboard');
        const questionsWrapperEl = document.getElementById('questions-wrapper');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const questionJumpEl = document.getElementById('question-jump');
        const resetQuizBtn = document.getElementById('reset-quiz-btn');
        const timerEl = document.getElementById('timer');

        // --- COOKIE HELPERS ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (JSON.stringify(value) || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) {
                    try {
                        return JSON.parse(c.substring(nameEQ.length, c.length));
                    } catch (e) {
                        return null;
                    }
                }
            }
            return null;
        }

        function deleteCookie(name) {
            document.cookie = name + '=; Max-Age=-99999999;';
        }

        // --- STATE PERSISTENCE ---
        function saveState() {
            const state = {
                currentQuestionIndex,
                score,
                userSelections,
                answeredCorrectly,
                totalSeconds
            };
            setCookie('quizState', state, 7); // Save state for 7 days
        }

        function loadState() {
            const savedState = getCookie('quizState');
            if (savedState) {
                currentQuestionIndex = savedState.currentQuestionIndex || 0;
                score = savedState.score || 0;
                userSelections = savedState.userSelections || Array(questions.length).fill(null).map(() => []);
                answeredCorrectly = savedState.answeredCorrectly || Array(questions.length).fill(false);
                totalSeconds = savedState.totalSeconds || 0;
                return true;
            } 
            return false;
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize arrays that depend on the 'questions' variable from test.js
            userSelections = Array(questions.length).fill(null).map(() => []);
            answeredCorrectly = Array(questions.length).fill(false);

            const stateLoaded = loadState(); // Load state from cookie before setting up the quiz
            setupQuiz();
            addEventListeners();
            if (!stateLoaded) {
                handleUserInteraction();
            }
        });

        function setupQuiz() {
            document.title = main_title;
            mainTitleEl.textContent = main_title;
            questionsWrapperEl.innerHTML = '';
            questionJumpEl.innerHTML = '';

            questions.forEach((q, index) => {
                renderQuestion(q, index);
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Question ${index + 1}`;
                questionJumpEl.appendChild(option);
            });

            // After rendering, apply the loaded state to the UI
            questions.forEach((q, index) => {
                const selections = userSelections[index];
                if (selections && selections.length > 0) {
                    const qContainer = document.getElementById(`question-${index}`);
                    selections.forEach(letter => {
                        const btn = qContainer.querySelector(`.option-btn[data-letter="${letter}"]`);
                        if (btn) {
                            btn.classList.add('selected', 'font-bold');
                        }
                    });
                    if (!answeredCorrectly[index]) {
                        qContainer.querySelector('.confirm-btn').disabled = userSelections[index].length !== q.correctAnswers.length;
                    }
                }
                if (answeredCorrectly[index]) {
                    applyConfirmedState(index);
                }
            });
            
            updateScoreboard();
            timerEl.textContent = formatTime(totalSeconds);
            showQuestion(currentQuestionIndex, true); // Show the last question without saving state again
        }
        
        function addEventListeners() {
            // Listener for all interactions inside the main container for delegation
            document.getElementById('quiz-container').addEventListener('click', (e) => {
                handleUserInteraction();
                dispatchInteraction(e);
            });
            document.getElementById('quiz-container').addEventListener('change', (e) => {
                handleUserInteraction();
                dispatchInteraction(e);
            });

            resetQuizBtn.addEventListener('click', resetQuiz);
        }

        // --- RENDERING ---
        function renderQuestion(question, index) {
            const questionContainer = document.createElement('div');
            questionContainer.id = `question-${index}`;
            questionContainer.className = 'question-container bg-white p-6 rounded-lg shadow-md mb-4 hidden';

            const choiceText = `(Choose ${question.correctAnswers.length})`;

           questionContainer.innerHTML = `
                <p class="text-gray-800 text-xl mb-4">${question.scenario}</p>
                <p class="text-lg font-medium mb-4">${question.questionText} <span class="text-sm font-normal text-gray-500">${question.isMultiChoice ? choiceText : '(Choose one)'}</span></p>
                <div class="options-grid grid grid-cols-1 gap-3 mb-4">
                    ${question.options.map(opt => `
                        <button class="option-btn w-full text-left p-4 border-2 border-gray-300 rounded-lg hover:bg-gray-100 transition-colors" data-question-index="${index}" data-letter="${opt.letter}">
                            <span class="font-bold mr-2">${opt.letter}.</span> ${opt.text}
                        </button>
                    `).join('')}
                </div>
                <div class="mt-4 flex justify-between items-center">
                    <button class="explanation-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed" data-question-index="${index}" disabled>Explanation</button>
                    <button class="confirm-btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed" data-question-index="${index}" disabled>Confirm</button>
                </div>
                <div class="explanation-box mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <p class="explanation-text whitespace-pre-wrap  text-base"></p>
                    <p class="wrong-explanation-text whitespace-pre-wrap  text-base mt-2"></p>
                </div>
            `;

            questionsWrapperEl.appendChild(questionContainer);
        }

        function applyConfirmedState(index) {
            const question = questions[index];
            const selections = userSelections[index];
            const qContainer = document.getElementById(`question-${index}`);
            const confirmBtn = qContainer.querySelector('.confirm-btn');
            const explanationBtn = qContainer.querySelector('.explanation-btn');
            const optionButtons = qContainer.querySelectorAll('.option-btn');

            confirmBtn.disabled = true;
            explanationBtn.disabled = false;
            optionButtons.forEach(btn => btn.disabled = true);

            optionButtons.forEach(btn => {
                const letter = btn.dataset.letter;
                if (question.correctAnswers.includes(letter)) {
                    btn.classList.add('correct');
                } else if (selections.includes(letter)) {
                    btn.classList.add('incorrect');
                }
            });

            const explanationBox = qContainer.querySelector('.explanation-box');
            explanationBox.querySelector('.explanation-text').textContent = question.explanation;
            explanationBox.querySelector('.wrong-explanation-text').textContent = question.wrongExplanation;
        }

        // --- LOGIC & EVENT HANDLERS (REFACTORED) ---
        function handleOptionSelect(selectedBtn) {
            const index = parseInt(selectedBtn.dataset.questionIndex);
            const letter = selectedBtn.dataset.letter;
            const question = questions[index];
            const parent = selectedBtn.closest('.options-grid');

            if (question.isMultiChoice) {
                const currentSelections = userSelections[index];
                const maxSelections = question.correctAnswers.length;

                if (currentSelections.includes(letter)) {
                    userSelections[index] = currentSelections.filter(l => l !== letter);
                    selectedBtn.classList.remove('selected', 'font-bold');
                } else {
                    if (currentSelections.length >= maxSelections) {
                        const oldestSelection = userSelections[index].shift();
                        const oldestBtn = parent.querySelector(`.option-btn[data-letter="${oldestSelection}"]`);
                        if (oldestBtn) {
                            oldestBtn.classList.remove('selected', 'font-bold');
                        }
                    }
                    userSelections[index].push(letter);
                    selectedBtn.classList.add('selected', 'font-bold');
                }
            } else {
                parent.querySelectorAll('.option-btn').forEach(btn => {
                    btn.classList.remove('selected', 'font-bold');
                });
                userSelections[index] = [letter];
                selectedBtn.classList.add('selected', 'font-bold');
            }
            
            const confirmBtn = document.querySelector(`#question-${index} .confirm-btn`);
            confirmBtn.disabled = userSelections[index].length !== question.correctAnswers.length;
            saveState();
        }

        function handleConfirm(confirmBtn) {
            const index = parseInt(confirmBtn.dataset.questionIndex);
            const question = questions[index];
            const selections = userSelections[index];
            
            const sortedSelections = [...selections].sort();
            const sortedCorrect = [...question.correctAnswers].sort();
            const isCorrect = JSON.stringify(sortedSelections) === JSON.stringify(sortedCorrect);
            
            if (isCorrect && !answeredCorrectly[index]) {
                score++;
                updateScoreboard();
            }
            
            answeredCorrectly[index] = true;
            applyConfirmedState(index);
            saveState();
        }

        function handleExplanationClick(btn) {
            const index = parseInt(btn.dataset.questionIndex);
            const explanationBox = document.querySelector(`#question-${index} .explanation-box`);
            explanationBox.classList.toggle('visible');
        }

        function showQuestion(index, isInitialLoad = false) {
            if (index < 0 || index >= questions.length) return;

            const currentQuestionEl = document.getElementById(`question-${currentQuestionIndex}`);
            if (currentQuestionEl) currentQuestionEl.classList.add('hidden');

            const newQuestionEl = document.getElementById(`question-${index}`);
            if (newQuestionEl) newQuestionEl.classList.remove('hidden');

            currentQuestionIndex = index;
            questionJumpEl.value = index;

            prevBtn.disabled = index === 0;
            nextBtn.disabled = index === questions.length - 1;

            if (!isInitialLoad) {
                saveState();
            }
        }

        function updateScoreboard() {
            scoreboardEl.textContent = `Score: ${score} / ${questions.length}`;
        }
        
        function resetQuiz() {
            deleteCookie('quizState'); 
            
            currentQuestionIndex = 0;
            score = 0;
            userSelections = Array(questions.length).fill(null).map(() => []);
            answeredCorrectly.fill(false);
            
            questions.forEach((q, index) => {
                const qContainer = document.getElementById(`question-${index}`);
                qContainer.querySelectorAll('.option-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('selected', 'correct', 'incorrect', 'font-bold');
                });
                qContainer.querySelector('.confirm-btn').disabled = true;
                qContainer.querySelector('.explanation-btn').disabled = true;
                qContainer.querySelector('.explanation-box').classList.remove('visible');
            });
            
            updateScoreboard();
            showQuestion(0);
            resetTimer();
            handleUserInteraction();
            location.reload();
        }
        
        // --- TIMER & INACTIVITY FUNCTIONS ---
        function handleUserInteraction() {
            clearTimeout(inactivityTimer);
            startTimer();
            inactivityTimer = setTimeout(stopTimer, 180000); // 3 minutes
        }
        
        function startTimer() {
            if (timerInterval) return;
            timerInterval = setInterval(() => {
                totalSeconds++;
                timerEl.textContent = formatTime(totalSeconds);
                saveState();
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
            clearTimeout(inactivityTimer);
        }

        function resetTimer() {
            stopTimer();
            totalSeconds = 0;
            timerEl.textContent = formatTime(totalSeconds);
            saveState();
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }
        
        // --- EVENT DISPATCHER ---
        function dispatchInteraction(event) {
            const target = event.target;
            
            const optionBtn = target.closest('.option-btn');
            if (optionBtn) {
                handleOptionSelect(optionBtn);
                return;
            }

            const confirmBtn = target.closest('.confirm-btn');
            if (confirmBtn) {
                handleConfirm(confirmBtn);
                return;
            }

            const explanationBtn = target.closest('.explanation-btn');
            if (explanationBtn) {
                handleExplanationClick(explanationBtn);
                return;
            }

            if (target.id === 'prev-btn') {
                 showQuestion(currentQuestionIndex - 1);
            } else if (target.id === 'next-btn') {
                 showQuestion(currentQuestionIndex + 1);
            } else if (target.id === 'question-jump') {
                showQuestion(parseInt(target.value));
            }
        }

    </script>

</body>
</html>
